/*
 * MyMove Orders Gateway
 *
 * API to submit, amend, and cancel orders for move.mil.
 *
 * API version: 0.0.5
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"io/ioutil"
	"net/url"
	"net/http"
	"strings"
	"golang.org/x/net/context"
	"encoding/json"
	"fmt"
)

// Linger please
var (
	_ context.Context
)

type OrdersApiService service


/* OrdersApiService Retrieve a set of Orders and all of its Revisions by UUID
 * @param ctx context.Context for authentication, logging, tracing, etc.
 @param uuid UUID of the orders to return
 @return Orders*/
func (a *OrdersApiService) GetOrders(ctx context.Context, uuid string) (Orders,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload  Orders
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/orders/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}


	return successPayload, localVarHttpResponse, err
}

/* OrdersApiService Retrieve orders that match a particular search
 Returns all orders that match all of the supplied parameters. At least one query parameter must be provided. 
 * @param ctx context.Context for authentication, logging, tracing, etc.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "ordersNum" (string) Orders number, corresponding to the ORDERS number (Army), the CT SDN (Navy, Marines), the SPECIAL ORDER NO (Air Force), the Travel Order No (Coast Guard), or the Travel Authorization Number (Civilian).
     @param "edipi" (string) Electronic Data Interchange Personal Identifier, AKA the 10 digit DoD ID Number of the member
     @param "latestOnly" (bool) If true, look only at the latest Revision (by seqNum) of any set of Orders when applying the other Revision-specific parameters. If false, search all Revisions.  Defaults to false if omitted. 
     @param "status" (string) Return only Orders where the status of the latest Revision of the Orders matches the supplied status.
     @param "issuer" (string) Name of the organization that issued the Orders.
 @return []Orders*/
func (a *OrdersApiService) IndexOrders(ctx context.Context, localVarOptionals map[string]interface{}) ([]Orders,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload  []Orders
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/orders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["ordersNum"], "string", "ordersNum"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["edipi"], "string", "edipi"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["latestOnly"], "bool", "latestOnly"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["status"], "string", "status"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["issuer"], "string", "issuer"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["ordersNum"].(string); localVarOk {
		localVarQueryParams.Add("ordersNum", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["edipi"].(string); localVarOk {
		localVarQueryParams.Add("edipi", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["latestOnly"].(bool); localVarOk {
		localVarQueryParams.Add("latestOnly", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["status"].(string); localVarOk {
		localVarQueryParams.Add("status", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["issuer"].(string); localVarOk {
		localVarQueryParams.Add("issuer", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}


	return successPayload, localVarHttpResponse, err
}

/* OrdersApiService Submit a new set of orders, make an amendment to an existing set of orders, or cancel a set of orders.
 Creates a Revision of a set of orders.  ## New Orders The supplied Revision is considered part of a new set of Orders if the combination of &#x60;ordersNum&#x60;, EDIPI, and &#x60;issuingAuthority&#x60; has never been seen before. A new UUID is created and associated with the Orders, which is returned along with the supplied Revision.  ## Amended Orders If the system determines that the supplied Revision is an amendment to an existing set of Orders, then the supplied Revision is added to the existing Orders.  If you stored the UUID of the Orders from a previous call to this API, you have the option of using the &#x60;POST /orders/{uuid}&#x60; API instead.  ## Canceled, Rescinded, or Revoked Orders To cancel, rescind, or revoke Orders, POST a new Revision with the status set to \&quot;canceled\&quot;.  # Errors It is an error to specify an already-created seqNum in the provided Revision for an existing set of Orders. 
 * @param ctx context.Context for authentication, logging, tracing, etc.
 @param ordersNum Orders number, corresponding to the ORDERS number (Army), the CT SDN (Navy, Marines), the SPECIAL ORDER NO (Air Force), the Travel Order No (Coast Guard), or the Travel Authorization Number (Civilian).
 @param memberId Electronic Data Interchange Personal Identifier of the member (preferred). If the member&#39;s EDIPI is unknown, then the Social Security Number may be provided instead. The Orders Gateway will then fetch the member&#39;s EDIPI using DMDC&#39;s Identity Web Services. Calls using the 9 digit SSN instead of the 10 digit EDIPI will take longer to respond due to the additional overhead. 
 @param revision 
 @return Orders*/
func (a *OrdersApiService) PostRevision(ctx context.Context, ordersNum string, memberId string, revision Revision) (Orders,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload  Orders
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/orders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}


	localVarQueryParams.Add("ordersNum", parameterToString(ordersNum, ""))
	localVarQueryParams.Add("memberId", parameterToString(memberId, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &revision
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}


	return successPayload, localVarHttpResponse, err
}

/* OrdersApiService Make an amendment to or cancel an existing set of orders by UUID
 Creates a Revision of a set of orders. The Orders to be amended or canceled must already exist with the supplied UUID.  The seqNum in the supplied Revision must be unique, and not already present in the Orders. Nothing else is required to change in the Revision compared to any other Revision in the Orders.  ## Errors It is an error to specify a non-existent UUID.  It is an error to specify an already-created seqNum in the Revision.  It is an error to specify a UUID for orders originally created by a different issuer. 
 * @param ctx context.Context for authentication, logging, tracing, etc.
 @param uuid UUID of the orders to return
 @param revision 
 @return Orders*/
func (a *OrdersApiService) PostRevisionToOrders(ctx context.Context, uuid string, revision Revision) (Orders,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload  Orders
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/orders/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &revision
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}


	return successPayload, localVarHttpResponse, err
}

