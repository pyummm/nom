/*
 * my.move.mil Orders Gateway
 *
 * API to submit, amend, and cancel orders for my.move.mil.
 *
 * API version: 0.0.3
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"io/ioutil"
	"net/url"
	"net/http"
	"strings"
	"golang.org/x/net/context"
	"encoding/json"
	"fmt"
)

// Linger please
var (
	_ context.Context
)

type OrdersApiService service


/* OrdersApiService Retrieve a set of Orders and all of its Revisions by UUID
 * @param ctx context.Context for authentication, logging, tracing, etc.
 @param uuid UUID of the orders to return
 @return Orders*/
func (a *OrdersApiService) GetOrders(ctx context.Context, uuid string) (Orders,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload  Orders
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/orders/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}


	return successPayload, localVarHttpResponse, err
}

/* OrdersApiService Retrieve orders that match a particular search
 Returns all orders that match all of the supplied parameters. At least one query parameter must be provided. 
 * @param ctx context.Context for authentication, logging, tracing, etc.
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "ordersNum" (string) The Orders number as it appears on the Orders
     @param "edipi" (string) Electronic Data Interchange Personal Identifier, AKA the 10 digit DoD ID Number of the member
     @param "latestOnly" (bool) If true, look only at the latest Revision (by seqNum) of any set of Orders when applying the other Revision-specific parameters. If false, search all Revisions.  Defaults to false if omitted. 
     @param "status" (string) Return only Orders where the status of the latest Revision of the Orders matches the supplied status.
     @param "issuingAuthority" (string) Name of the Issuing Authority of the Orders.
 @return []Orders*/
func (a *OrdersApiService) IndexOrders(ctx context.Context, localVarOptionals map[string]interface{}) ([]Orders,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload  []Orders
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/orders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["ordersNum"], "string", "ordersNum"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["edipi"], "string", "edipi"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["latestOnly"], "bool", "latestOnly"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["status"], "string", "status"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["issuingAuthority"], "string", "issuingAuthority"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["ordersNum"].(string); localVarOk {
		localVarQueryParams.Add("ordersNum", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["edipi"].(string); localVarOk {
		localVarQueryParams.Add("edipi", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["latestOnly"].(bool); localVarOk {
		localVarQueryParams.Add("latestOnly", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["status"].(string); localVarOk {
		localVarQueryParams.Add("status", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["issuingAuthority"].(string); localVarOk {
		localVarQueryParams.Add("issuingAuthority", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}


	return successPayload, localVarHttpResponse, err
}

/* OrdersApiService Submit a new set of orders, make an amendment to an existing set of orders, or cancel a set of orders.
 Creates a Revision of a set of orders.  ## New Orders The supplied Revision is considered part of a new set of Orders if the supplied ordersNum has never been seen before for the supplied issuingAuthority. A new UUID is created and associated with a new Orders, which is returned along with the supplied Revision.  ## Amended Orders If the system determines that the supplied Revision is an amendment to an existing set of Orders, usually because the ordersNum already exists and the seqNum is unique, then the supplied Revision is added to the existing Orders.  Specifying the existing Orders&#39; UUID is optional; clients are not required to remember the UUIDs returned with the Orders by previous calls to this API. If it is omitted, the system will attempt to locate the correct Orders using the ordersNum and issuingAuthority fields.  ## Canceled, Rescinded, or Revoked Orders To cancel, rescind, or revoke Orders, POST a new Revision with the status set to \&quot;canceled\&quot;.  # Errors It is an error to specify an already-created seqNum in the provided Revision for an existing set of Orders. 
 * @param ctx context.Context for authentication, logging, tracing, etc.
 @param ordersNum The Orders number as it appears on the Orders
 @param edipi Electronic Data Interchange Personal Identifier, AKA the 10 digit DoD ID Number of the member
 @param issuingAuthority Name of the Issuing Authority of the Orders.
 @param revision 
 @return Orders*/
func (a *OrdersApiService) PostRevision(ctx context.Context, ordersNum string, edipi string, issuingAuthority string, revision Revision) (Orders,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload  Orders
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/orders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}


	localVarQueryParams.Add("ordersNum", parameterToString(ordersNum, ""))
	localVarQueryParams.Add("edipi", parameterToString(edipi, ""))
	localVarQueryParams.Add("issuingAuthority", parameterToString(issuingAuthority, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &revision
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}


	return successPayload, localVarHttpResponse, err
}

/* OrdersApiService Make an amendment to or cancel an existing set of orders by UUID
 Creates a Revision of a set of orders. The Orders to be amended or canceled must already exist with the supplied UUID.  The seqNum in the supplied Revision must be unique, and not already present in the Orders. Nothing else is required to change in the Revision compared to any other Revision in the Orders.  ## Errors It is an error to specify a non-existent UUID.  It is an error to specify an already-created seqNum in the Revision. 
 * @param ctx context.Context for authentication, logging, tracing, etc.
 @param uuid UUID of the orders to return
 @param revision 
 @return Orders*/
func (a *OrdersApiService) PostRevisionToOrders(ctx context.Context, uuid string, revision Revision) (Orders,  *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody interface{}
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload  Orders
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/orders/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{ "application/json",  }

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &revision
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}


	return successPayload, localVarHttpResponse, err
}

